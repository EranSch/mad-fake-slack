{{! template-lint-disable no-inline-styles }}
<form id="msg_form" class="offline" method="POST" action="/api/chat.postMessage" enctype="multipart/form-data">
  <div class="msg_input_wrapper">
    <input type="hidden" name="channel" value={{channel.id}}>
    <input type="hidden" name="type" value="message">
    <input type="hidden" name="ts" value={{makeTs}}>
    <div id="msg_input" class="texty_legacy ql-container focus">
      <div class="ql-editor ql-blank" dir="auto">
        <p>
          <textarea
            id="msg_input_text"
            autofocus="true"
            name="text"
            class="ql-input-msg"
            value=""
            rows="1"
            placeholder="Type text here"
            spellcheck="true"
            autocorrect="off"
            autocomplete="off"
            style="resize: none;"></textarea>
        </p>
      </div>
      <div class="ql-clipboard" contenteditable="true" tabindex="-1" aria-hidden="true" role="presentation"
        spellcheck="true" autocorrect="off" autocomplete="off">
      </div>
    </div>
    <button type="button" id="primary_file_button" tabindex="2">
      <i class="im im-plus"></i>
    </button>
    <input type="file" id="file_upload" class="offscreen" multiple="" tabindex="-1">
    <button type="button" id="main_emo_menu" class="btn_unstyle emo_menu" tabindex="4">
      <i class="im im-smiley-o ts-icon ts_icon_mentions"></i>
    </button>
    <button type="button" class="btn_unstyle msg_mentions_button" tabindex="3">
      <i class="im im-link ts-icon ts_icon_mentions"></i>
    </button>
    <div id="msg_input_message">
    </div>
    <div>
      <div id="notification_bar">
        <div class="p-notification_bar p-notification_bar--legacy">
          <div class="p-notification_bar__section p-notification_bar__section--left"></div>
          <div class="p-notification_bar__section p-notification_bar__section--right">
            <span class="p-notification_bar__formatting" aria-hidden="true">
              <b>*bold*</b>
              <i>_italics_</i>
              ~strike~
              <code>`code`</code>
              <code>```preformatted```</code>
              <span>&gt;quote</span>
            </span>
          </div>
        </div>
      </div>
    </div>
  </div>
  <button id="msg_input_send" type="button" class="btn msg_input_btn hidden" tabindex="1">
    Send
  </button>
</form>
<script>
  function setEndOfContenteditable(contentEditableElement) {
      var range, selection;
      if (document.createRange)//Firefox, Chrome, Opera, Safari, IE 9+
      {
        range = document.createRange();//Create a range (a range is a like the selection but invisible)
        range.selectNodeContents(contentEditableElement);//Select the entire contents of the element with the range
        range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start
        selection = window.getSelection();//get the selection object (allows you to change selection)
        selection.removeAllRanges();//remove any selections already made
        selection.addRange(range);//make the range you have just created the visible selection
      }
      else if (document.selection)//IE 8 and lower
      {
        range = document.body.createTextRange();//Create a range (a range is a like the selection but invisible)
        range.moveToElementText(contentEditableElement);//Select the entire contents of the element with the range
        range.collapse(false);//collapse the range to the end point. false means collapse to end rather than the start
        range.select();//Select the range (make it the visible selection
      }
  }

  class InlineEditLastMessage {
    constructor(container, messageInput) {
      this.container = container;
      this.messageInput = messageInput;
      this.editEl = null;
      this.editMode = false;
    }

    handlerEditInput = (e) => {
      Handlebars.userUtils.scrollToLastMessage();
    }

    handlerEditKeyDown = (e) => {
      if (e.keyCode == 27) {
        e.preventDefault();
        this.cancel();
        setTimeout(() => {
          this.messageInput.focus();
        }, 0);
      }
    }

    handlerCancel = (e) => {
      e.preventDefault();
      this.cancel();
    }

    handlerSave = (e) => {
      e.preventDefault();
      this.done();
    }

    setupEvents() {
      if (this.editorEl) {
        this.editorEl.addEventListener('input', this.handlerEditInput);
        this.editorEl.addEventListener('keydown', this.handlerEditKeyDown);
      }
      if (this.cancelBtn) {
        this.cancelBtn.addEventListener('click', this.handlerCancel);
      }
      if(this.saveBtn) {
        this.saveBtn.addEventListener('click', this.handlerSave);
      }
    }

    cleanupEvents() {
      if (this.editorEl) {
        this.editorEl.removeEventListener('input', this.handlerEditInput);
        this.editorEl.removeEventListener('keydown', this.handlerEditKeyDown);
      }
      if (this.cancelBtn) {
        this.cancelBtn.removeEventListener('click', this.handlerCancel);
      }
      if (this.saveBtn) {
        this.saveBtn.removeEventListener('click', this.handlerSave);
      }
    }

    getLastMessage() {
      const lastMessageIndex = Handlebars.context.getLastMyMessageIndex();
      return [Handlebars.context.messages[lastMessageIndex], lastMessageIndex];
    }

    setFocus() {
      if (this.editorEl) {
        this.editorEl.focus();
        setEndOfContenteditable(this.editorEl);
      }
    }

    setupElements([message, index]) {
      this.editEl = this.renderMessage([message, index]);
      this.editorEl = this.editEl.querySelector('.ql-editor');
      this.cancelBtn = window.emd_cancel_button;
      this.saveBtn = window.emd_save_button;
    }

    renderMessage([message, index]) {
      return Handlebars.renderAtIndex(index, this.container, "message_edit", { message });
    }

    scrollToIndex(index) {
      Handlebars.userUtils.scrollToMessageAtIndex(index);
    }

    async sendUpdate({ text, ts }) {
      const selectedChannel = Handlebars.context.getSelectedChannel();
      if (!text || !text.trim()) {
        throw new Error('Text is required');
      }
      const result = await Handlebars.userUtils.postJson('/api/chat.update', {
        text,
        ts,
        channel: selectedChannel.id
      });
      if (!result.ok) {
        throw new Error(result.error);
      }
    }

    edit() {
      const [lastMessage, lastMessageIndex] = this.getLastMessage();
      if (!lastMessage) return;
      this.replaceMsgMessageEl = this.container.children[lastMessageIndex];
      this.replaceMsgMessageEl.remove();
      this.setupElements([lastMessage, lastMessageIndex]);
      this.setupEvents();
      this.scrollToIndex(lastMessageIndex);
      this.setFocus();
      this.editMode = true;
    }

    cancel() {
      const [lastMessage] = this.getLastMessage();
      this.complete();
    }

    done() {
      const [lastMessage] = this.getLastMessage();
      lastMessage.text = this.editorEl.textContent;
      this.sendUpdate(lastMessage).then(() => this.complete());
    }

    complete() {
      this.cleanupEvents();
      if (this.editEl) {
        this.editEl.remove();
        this.editEl = null;
        this.editorEl = null;
      }
      const [lastMessage, lastMessageIndex] = this.getLastMessage();
      Handlebars.renderAtIndex(lastMessageIndex, this.container, "message", { message: lastMessage });
      Handlebars.userUtils.scrollToMessageAtIndex(lastMessageIndex);
      this.editMode = false;
    }

    isInEditMode() {
      return this.editMode;
    }
  }

  const msgForm = window.msg_form;
  const msgInputText = window.msg_input_text;
  const msgContainer = window.messages_container;
  const msgInputArea = window.msg_input;
  let inlineEditor = null;
  function updateTextAreaHeight() {
    msgInputArea.setAttribute('style', `height:1px;`);
    const h = msgInputText.scrollHeight;
    if (h) {
      msgInputArea.setAttribute('style', `height:${h > 180 ? 180 : h}px;`);
      Handlebars.userUtils.scrollToLastMessage();
    }
  }

  function pasteIntoInput(el, text) {
    el.focus();
    if (typeof el.selectionStart == "number"
      && typeof el.selectionEnd == "number") {
      var val = el.value;
      var selStart = el.selectionStart;
      el.value = val.slice(0, selStart) + text + val.slice(el.selectionEnd);
      el.selectionEnd = el.selectionStart = selStart + text.length;
    } else if (typeof document.selection != "undefined") {
      var textRange = document.selection.createRange();
      textRange.text = text;
      textRange.collapse(false);
      textRange.select();
    }
  }

  msgInputText.addEventListener('keyup', (e) => {
      setTimeout(updateTextAreaHeight, 0);
  });

  msgInputText.addEventListener('keydown', (e) => {
    if (e.keyCode === 38) {
      e.preventDefault();
      if (!inlineEditor) {
        inlineEditor = new InlineEditLastMessage(msgContainer, msgInputText);
      }
      if (!inlineEditor.isInEditMode()) {
        inlineEditor.edit();
      }
    }
    if (e.keyCode === 13) {
      e.preventDefault();
      if (e.ctrlKey || e.shiftKey) {
        pasteIntoInput(e.currentTarget, '\n');
        msgInputText.scrollTop = msgInputText.scrollHeight;
      } else {
        const event = new CustomEvent('submit', { "bubbles": true, "cancelable": true });
        msgForm.dispatchEvent(event);
      }
    }
  });

  const throttle = (func, limit) => {
    let lastFunc;
    let lastRan;
    return function () {
      const context = this
      const args = Array.from(arguments);
      if (!lastRan) {
        func.apply(context, args)
        lastRan = Date.now()
      } else {
        clearTimeout(lastFunc)
        lastFunc = setTimeout(function () {
          if ((Date.now() - lastRan) >= limit) {
            func.apply(context, args)
            lastRan = Date.now()
          }
        }, limit - (Date.now() - lastRan))
      }
    }
  }

  msgInputText.addEventListener('input', throttle((e) => {
    const user = Handlebars.context.me.id;
    const channel = Handlebars.context.getSelectedChannel().id;
    Handlebars.ws.emitJSON({ type: "user_typing", channel, user });
  }, 5000));

  msgForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (e.target.id !== "msg_form") return;
    const data = new FormData(e.target);
    if (data.get('text').trim()) {
      const ts = Handlebars.helpers.makeTs();
      data.set('ts', ts);

      const context = {
        message: {
            team: { id: Handlebars.context.me.team_id },
            team_id: Handlebars.context.me.team_id,
            user: Handlebars.createFrame(Handlebars.context.me),
            user_id: Handlebars.context.me.id,
            ts,
            text: data.get('text')
        }
      };

      let message = Handlebars.render(msgContainer, "message", context);
      Handlebars.userUtils.scrollToLastMessage();
      msgInputText.value = "";
      const formData = Array.from(data.entries()).reduce((o, [k, v]) => {
        o[k] = v;
        return o;
      }, {});
      const result = await Handlebars.userUtils.postJson(msgForm.action, formData);
      if (result.ok) {
        message.ts = result.ts;
      }
    }
  });
</script>
